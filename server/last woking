const express = require("express");
const axios = require("axios");
const cors = require("cors");
require("dotenv").config();
const { GoogleGenAI } = require("@google/genai");

const { connectMongo, Context, Replied, PostState } = require("./db");

const app = express();
app.use(express.json());
app.use(cors({ origin: "*", methods: ["GET", "POST", "PUT", "DELETE"] }));

const port = process.env.PORT || 3000;

const IG_APP_ID = process.env.INSTAGRAM_APP_ID;
const IG_APP_SECRET = process.env.INSTAGRAM_APP_SECRET;
const VERIFY_TOKEN = process.env.VERIFY_TOKEN;

const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

function log(...args) {
  console.log(new Date().toISOString(), "-", ...args);
}

// ---------------- helpers ----------------
async function fetchAllPages(startUrl) {
  const all = [];
  let url = startUrl;
  while (url) {
    const { data } = await axios.get(url);
    if (data?.data?.length) all.push(...data.data);
    url = data?.paging?.next || null;
  }
  return all;
}

// Fetch your own IG username so we can skip replying to ourselves
async function getMyUsername(accessToken) {
  const url = `https://graph.instagram.com/me?fields=id,username&access_token=${accessToken}`;
  const { data } = await axios.get(url);
  return data?.username || null;
}

async function replyToComment(commentId, message, accessToken) {
  const url = `https://graph.instagram.com/${commentId}/replies`;
  try {
    const r = await axios.post(url, null, {
      params: { message, access_token: accessToken },
    });
    return r.data; // sometimes includes created reply id
  } catch (e) {
    log("âŒ replyToComment failed", {
      commentId,
      err: e?.response?.data || e?.message,
    });
    throw e;
  }
}

async function generateReply(comment, context) {
  try {
    const prompt = `
You are a friendly customer support agent.
Rules:
- Answer ONLY using the provided context.
- If the answer isn't in the context, be polite and do not invent details; keep it short.
- Return EXACTLY ONE sentence.
User Comment: "${comment}"
Context: "${context}"
`;

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: prompt,
    });

    const text =
      (typeof response?.text === "string" && response.text) ||
      (typeof response?.text === "function" && response.text()) ||
      "";

    const out = String(text).trim().replace(/\s+/g, " ");
    log("ðŸ§  Gemini reply:", out);
    return out || "Thanks for your comment! ðŸ˜Š";
  } catch (e) {
    log("âŒ Gemini error:", e?.message || e);
    return "Thanks for your comment! ðŸ˜Š";
  }
}

// ---------------- Token exchange ----------------
app.post("/api/instagram-token", async (req, res) => {
  const { code, redirect_uri: redirectUri, client_id: clientIdFromBody } = req.body || {};
  const clientId = IG_APP_ID || clientIdFromBody;

  if (!IG_APP_SECRET) return res.status(500).json({ error: "Missing INSTAGRAM_APP_SECRET" });
  if (!clientId || !code || !redirectUri) {
    return res.status(400).json({ error: "Missing client_id, code, or redirect_uri" });
  }

  try {
    const form = new URLSearchParams({
      client_id: clientId,
      client_secret: IG_APP_SECRET,
      grant_type: "authorization_code",
      redirect_uri: redirectUri,
      code,
    });

    const igResponse = await fetch("https://api.instagram.com/oauth/access_token", {
      method: "POST",
      body: form,
    });

    const text = await igResponse.text();
    if (!igResponse.ok) return res.status(igResponse.status).send(text || "Token exchange failed");

    const json = JSON.parse(text);
    if (!json.access_token || !json.user_id) {
      return res.status(502).json({ error: "No access_token/user_id returned" });
    }

    return res.status(200).json(json);
  } catch (err) {
    return res.status(500).json({ error: err?.message || "Unexpected error" });
  }
});

// ---------------- Context CRUD ----------------
app.put("/api/context", async (req, res) => {
  const { userId, postId, text } = req.body || {};
  if (!userId || !postId) return res.status(400).json({ error: "Missing userId or postId" });
  if (!text || !String(text).trim()) return res.status(400).json({ error: "Context text required" });

  const doc = await Context.findOneAndUpdate(
    { userId: String(userId), postId: String(postId) },
    { text: String(text) },
    { upsert: true, new: true }
  );

  log("âœ… Context saved", { userId: String(userId), postId: String(postId), len: String(text).length });
  res.json({ ok: true, context: doc });
});

app.get("/api/context", async (req, res) => {
  const { userId } = req.query || {};
  if (!userId) return res.status(400).json({ error: "Missing userId" });

  const rows = await Context.find({ userId: String(userId) }).lean();
  const map = {};
  for (const r of rows) map[r.postId] = r.text;

  log("ðŸ“¦ Context loaded", { userId: String(userId), count: rows.length });
  res.json({ ok: true, contextMap: map });
});

app.delete("/api/context", async (req, res) => {
  const { userId, postId } = req.body || {};
  if (!userId || !postId) return res.status(400).json({ error: "Missing userId or postId" });

  await Context.deleteOne({ userId: String(userId), postId: String(postId) });
  log("ðŸ—‘ï¸ Context deleted", { userId: String(userId), postId: String(postId) });
  res.json({ ok: true });
});

// ---------------- PostState per-post ON/OFF ----------------
app.put("/api/post-state", async (req, res) => {
  const { userId, postId, enabled } = req.body || {};
  if (!userId || !postId) return res.status(400).json({ error: "Missing userId or postId" });

  const isOn = Boolean(enabled);
  const update = { autoReplyEnabled: isOn, sinceMs: isOn ? Date.now() : null };

  const st = await PostState.findOneAndUpdate(
    { userId: String(userId), postId: String(postId) },
    update,
    { upsert: true, new: true }
  );

  log("âœ… PostState updated", { userId: String(userId), postId: String(postId), isOn, sinceMs: st.sinceMs });
  res.json({ ok: true, state: st });
});

app.get("/api/post-state", async (req, res) => {
  const { userId } = req.query || {};
  if (!userId) return res.status(400).json({ error: "Missing userId" });

  const states = await PostState.find({ userId: String(userId) }).lean();
  const map = {};
  for (const s of states) {
    map[s.postId] = { autoReplyEnabled: Boolean(s.autoReplyEnabled), sinceMs: s.sinceMs || null };
  }

  log("ðŸ“¦ PostStates loaded", { userId: String(userId), count: states.length });
  res.json({ ok: true, stateMap: map });
});

// ---------------- Posts + Comments + Auto Reply (DB-driven) ----------------
app.post("/posts", async (req, res) => {
  try {
    const { access_token: accessToken, user_id: userId } = req.body || {};
    log("âž¡ï¸ /posts called", { hasToken: Boolean(accessToken), userId });

    if (!accessToken || !userId) return res.status(400).json({ error: "Missing access_token or user_id" });

    // âœ… important: get your own username once so we can skip self-comments
    let myUsername = null;
    try {
      myUsername = await getMyUsername(accessToken);
      log("ðŸ‘¤ My username", { myUsername });
    } catch (e) {
      log("âš ï¸ Could not fetch my username (will rely on DB + text filters)", e?.message || e);
    }

    const postFields = "id,caption,media_type,permalink,timestamp,like_count,comments_count";
    const postsUrl = `https://graph.instagram.com/${userId}/media?fields=${encodeURIComponent(
      postFields
    )}&access_token=${accessToken}`;
    const posts = await fetchAllPages(postsUrl);
    log("ðŸ§¾ Posts fetched", { count: posts.length });

    const [ctxRows, states] = await Promise.all([
      Context.find({ userId: String(userId) }).lean(),
      PostState.find({ userId: String(userId) }).lean(),
    ]);

    const contextMap = {};
    for (const r of ctxRows) contextMap[r.postId] = r.text;

    const stateMap = {};
    for (const s of states) stateMap[s.postId] = s;

    log("ðŸ“¦ DB preload", { contexts: ctxRows.length, postStates: states.length });

    const postsWithComments = await Promise.all(
      posts.map(async (p) => {
        const commentsUrl = `https://graph.instagram.com/${p.id}/comments?fields=${encodeURIComponent(
          "id,text,username,timestamp"
        )}&access_token=${accessToken}`;

        const comments = await fetchAllPages(commentsUrl);

        const postContext = contextMap[p.id] ? String(contextMap[p.id]) : "";
        const st = stateMap[p.id] || { autoReplyEnabled: false, sinceMs: null };
        const enabled = Boolean(st.autoReplyEnabled);
        const sinceMs = typeof st.sinceMs === "number" ? st.sinceMs : null;

        log("ðŸ§© Post check", {
          postId: p.id,
          enabled,
          sinceMs,
          comments: comments.length,
          contextLen: postContext.length,
        });

        // Only reply if enabled + has context + has sinceMs
        if (enabled && sinceMs && postContext.trim()) {
          const eligible = comments
            .map((c) => ({ ...c, _ms: Date.parse(c.timestamp || "") || 0 }))
            .filter((c) => c._ms >= sinceMs)
            .filter((c) => {
              // âœ… FIX: do not reply to your own comments/replies
              if (
                myUsername &&
                c.username &&
                String(c.username).toLowerCase() === String(myUsername).toLowerCase()
              ) {
                return false;
              }

              // Optional additional protection (prevents loops if username is missing)
              const t = String(c.text || "").toLowerCase();
              if (t.includes("thanks for your comment")) return false;

              return true;
            })
            .sort((a, b) => b._ms - a._ms);

          const newest = eligible[0];

          if (!newest) {
            log("â­ï¸ No eligible comments after sinceMs", { postId: p.id });
          } else {
            const already = await Replied.findOne({
              userId: String(userId),
              commentId: String(newest.id),
            }).lean();

            if (already) {
              log("â­ï¸ Already replied (DB)", { postId: p.id, commentId: newest.id });
            } else {
              log("âœ… Replying to comment", { postId: p.id, commentId: newest.id, text: newest.text });

              try {
                const aiReply = await generateReply(newest.text || "", postContext);

                const replyResult = await replyToComment(newest.id, aiReply, accessToken);

                // mark original comment as replied
                await Replied.create({
                  userId: String(userId),
                  postId: String(p.id),
                  commentId: String(newest.id),
                });

                // optional: also mark the created reply id (if API returns it)
                if (replyResult?.id) {
                  try {
                    await Replied.create({
                      userId: String(userId),
                      postId: String(p.id),
                      commentId: String(replyResult.id),
                    });
                  } catch (_) {
                    // ignore duplicate key if it happens
                  }
                }

                log("ðŸŽ‰ Replied + saved", { postId: p.id, commentId: newest.id });
              } catch (e) {
                log("âŒ Reply pipeline failed", {
                  postId: p.id,
                  commentId: newest.id,
                  err: e?.response?.data || e?.message,
                });
              }
            }
          }
        } else {
          if (!enabled) log("â­ï¸ Skip: enabled=false", { postId: p.id });
          else if (!sinceMs) log("â­ï¸ Skip: sinceMs missing", { postId: p.id });
          else if (!postContext.trim()) log("â­ï¸ Skip: context missing", { postId: p.id });
        }

        return {
          ...p,
          comments,
          context: postContext,
          autoReplyEnabled: enabled,
        };
      })
    );

    res.json({
      posts: postsWithComments,
      contextMap,
      stateMap: Object.fromEntries(
        Object.entries(stateMap).map(([postId, st]) => [
          postId,
          { autoReplyEnabled: Boolean(st.autoReplyEnabled), sinceMs: st.sinceMs || null },
        ])
      ),
    });
  } catch (e) {
    log("âŒ /posts global error", e?.response?.data || e.message);
    res.status(500).json({ error: e?.response?.data || e.message });
  }
});

// ---------------- webhook verify (optional) ----------------
app.get("/api/instagram-webhook", (req, res) => {
  if (req.query["hub.mode"] === "subscribe" && req.query["hub.verify_token"] === VERIFY_TOKEN) {
    return res.status(200).send(req.query["hub.challenge"]);
  }
  return res.status(200).send("Webhook active");
});

// ---------------- start ----------------
connectMongo()
  .then(() => app.listen(port, () => log(`http://localhost:${port}`)))
  .catch((err) => {
    log("Mongo connection failed:", err.message);
    process.exit(1);
  });
